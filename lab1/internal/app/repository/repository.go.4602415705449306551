package repository

import (
	"fmt"
	"strings"
)

const (
	minioEndpoint = "http://localhost:9000"
	minioBucket   = "xrf-media"
)

type Service struct {
	ID             string
	Name           string
	Era            string
	Culture        string
	DateLabel      string
	PriceRUB       int
	Description    string
	FeKAlpha       string
	CuKAlpha       string
	ZnKAlpha       string
	SnLAlpha       string
	PbLAlpha       string
	ImageObjectKey string
	VideoObjectKey string
	ImageURL       string
	VideoURL       string
}

type ClaimLine struct {
	ServiceID         string
	MMField           string
	CalculationResult string
}

type Claim struct {
	ID              string
	ArtifactID      string
	ArtifactTitle   string
	ArtifactOrigin  string
	ScanDate        string
	AnalyzerModel   string
	SearchGoal      string
	TotalResult     string
	OperatorComment string
	Lines           []ClaimLine
}

type Repository struct {
	services []Service
	claims   map[string]Claim
}

func NewRepository() (*Repository, error) {
	return &Repository{
		services: seedServices(),
		claims:   seedClaims(),
	}, nil
}

func (r *Repository) GetServices() []Service {
	result := make([]Service, len(r.services))
	copy(result, r.services)
	return result
}

func (r *Repository) SearchServicesByName(query string) []Service {
	normalizedQuery := strings.ToLower(strings.TrimSpace(query))
	if normalizedQuery == "" {
		return r.GetServices()
	}

	result := make([]Service, 0, len(r.services))
	for _, service := range r.services {
		if strings.Contains(strings.ToLower(service.Name), normalizedQuery) {
			result = append(result, service)
		}
	}

	return result
}

func (r *Repository) GetServiceByID(id string) (Service, error) {
	for _, service := range r.services {
		if service.ID == id {
			return service, nil
		}
	}

	return Service{}, fmt.Errorf("service with id %q not found", id)
}

func (r *Repository) GetClaimByID(id string) (Claim, error) {
	claim, ok := r.claims[id]
	if !ok {
		return Claim{}, fmt.Errorf("claim with id %q not found", id)
	}

	return claim, nil
}

func seedServices() []Service {
	return []Service{
		{
			ID:             "alloy-bronze-cyprus",
			Name:           "Бронза Кипра",
			Era:            "Поздний бронзовый век",
			Culture:        "Восточное Средиземноморье",
			DateLabel:      "Обновлено 2026-02-10",
			PriceRUB:       5200,
			Description:    "Эталонный спектральный профиль для бронзовых артефактов при сравнении сигналов Cu/Sn/Pb в рентгенофлуоресцентном анализе.",
			FeKAlpha:       "6.40 keV / 0.16",
			CuKAlpha:       "8.04 keV / 0.83",
			ZnKAlpha:       "8.64 keV / 0.04",
			SnLAlpha:       "3.44 keV / 0.31",
			PbLAlpha:       "10.55 keV / 0.12",
			ImageObjectKey: "bronze.png",
			VideoObjectKey: "bronze.mp4",
			ImageURL:       mediaURL("bronze.png"),
			VideoURL:       mediaURL("bronze.mp4"),
		},
		{
			ID:             "alloy-brass-rome",
			Name:           "Латунь Рима",
			Era:            "I-III вв. н.э.",
			Culture:        "Римская империя",
			DateLabel:      "Обновлено 2026-02-11",
			PriceRUB:       4900,
			Description:    "База латуни с высоким вкладом Zn для идентификации позднеантичных изделий и оценки технологических примесей Pb.",
			FeKAlpha:       "6.40 keV / 0.08",
			CuKAlpha:       "8.04 keV / 0.78",
			ZnKAlpha:       "8.64 keV / 0.64",
			SnLAlpha:       "3.44 keV / 0.06",
			PbLAlpha:       "10.55 keV / 0.03",
			ImageObjectKey: "brass.png",
			VideoObjectKey: "brass.mp4",
			ImageURL:       mediaURL("brass.png"),
			VideoURL:       mediaURL("brass.mp4"),
		},
		{
			ID:             "alloy-iron-north",
			Name:           "Железный сплав Севера",
			Era:            "VIII-XI вв.",
			Culture:        "Скандинавские мастерские",
			DateLabel:      "Обновлено 2026-02-12",
			PriceRUB:       5800,
			Description:    "Контрольный железный профиль с высоким Fe для отсечения ошибочных совпадений с бронзовыми и латунными группами.",
			FeKAlpha:       "6.40 keV / 0.73",
			CuKAlpha:       "8.04 keV / 0.14",
			ZnKAlpha:       "8.64 keV / 0.02",
			SnLAlpha:       "3.44 keV / 0.01",
			PbLAlpha:       "10.55 keV / 0.01",
			ImageObjectKey: "iron.png",
			VideoObjectKey: "iron.mp4",
			ImageURL:       mediaURL("iron.png"),
			VideoURL:       mediaURL("iron.mp4"),
		},
		{
			ID:             "alloy-silver-byzantium",
			Name:           "Серебро Византии",
			Era:            "X-XII вв.",
			Culture:        "Византийские мастерские",
			DateLabel:      "Обновлено 2026-02-13",
			PriceRUB:       6100,
			Description:    "Эталон для монет и украшений с Ag/Cu системой, используется для оценки доли легирования и реставрационных добавок.",
			FeKAlpha:       "6.40 keV / 0.03",
			CuKAlpha:       "8.04 keV / 0.29",
			ZnKAlpha:       "8.64 keV / 0.01",
			SnLAlpha:       "3.44 keV / 0.00",
			PbLAlpha:       "10.55 keV / 0.09",
			ImageObjectKey: "silver.png",
			VideoObjectKey: "silver.mp4",
			ImageURL:       mediaURL("silver.png"),
			VideoURL:       mediaURL("silver.mp4"),
		},
	}
}

func seedClaims() map[string]Claim {
	return map[string]Claim{
		"artifact-001": {
			ID:              "artifact-001",
			ArtifactID:      "artifact-ax-17",
			ArtifactTitle:   "Фрагмент поясной накладки",
			ArtifactOrigin:  "Южное Причерноморье, раскоп 2025",
			ScanDate:        "2026-02-21",
			AnalyzerModel:   "Vanta C-series",
			SearchGoal:      "Рассчитать процентное содержание элементов и подобрать ближайший эталонный сплав",
			TotalResult:     "Итог: Cu 79%, Zn 19%, Pb 2%; идентификация: Латунь Рима",
			OperatorComment: "Интенсивности нормированы, фон очищен, повторяемость 3/3.",
			Lines: []ClaimLine{
				{
					ServiceID:         "alloy-bronze-cyprus",
					MMField:           "m-m: порядок=1, комментарий=высокая близость по Cu и Pb",
					CalculationResult: "Cu 88%, Sn 10%, Pb 2%",
				},
				{
					ServiceID:         "alloy-brass-rome",
					MMField:           "m-m: порядок=2, комментарий=лучшее совпадение по Zn",
					CalculationResult: "Cu 79%, Zn 19%, Pb 2%",
				},
				{
					ServiceID:         "alloy-iron-north",
					MMField:           "m-m: порядок=3, комментарий=отрицательный контроль",
					CalculationResult: "Fe 92%, Cu 5%, примеси 3%",
				},
			},
		},
	}
}

func mediaURL(objectKey string) string {
	return fmt.Sprintf("%s/%s/%s", minioEndpoint, minioBucket, objectKey)
}
